[
  {"id": 1, "use": true, "param": "n_estimators", "type": "int", "default_value": 100, "name": "Оценка", "info": "Количество деревьев в лесу.", "diap": [10, 100]},
  {"id": 2, "use": true, "param": "criterion", "type": "string", "default_value": {"label": "gini", "value":  "gini"}, "name": "Качество разделения", "info": "Функция для измерения качества разделения.", "diap": ["gini", "entropy", "log_loss"]},
  {"id": 3, "use": true, "param": "max_depth", "type": "int", "default_value": null, "name": "Максимальная глубина дерева", "info": "Если None, то узлы расширяются до тех пор, пока все листья не станут чистыми или пока все листья не будут содержать менее min_samples_split выборок.", "diap": [0]},
  {"id": 4, "use": true, "param": "min_samples_split", "type": "float", "default_value": 0.2, "name": "Минимальное разбиение выбоки", "info": "Если число с плавающей запятой, то min_samples_splitэто дробь и минимальное количество выборок для каждого разделения.ceil(min_samples_split * n_samples)", "diap": [0, 1]},
  {"id": 5, "use": true, "param": "min_samples_leaf", "type": "int", "default_value": 1, "name": "Минимальное количество выборок, которое должно находиться в листовом узле.", "info": "Точка разделения на любой глубине будет учитываться только в том случае, если она оставляет хотя бы min_samples_leafобучающие выборки в каждой из левой и правой ветвей. Это может привести к сглаживанию модели, особенно в регрессионном режиме. Если int, то считать min_samples_leafминимальным числом. Если с плавающей запятой, то min_samples_leafэто дробь и минимальное количество выборок для каждого узла.ceil(min_samples_leaf * n_samples)", "diap": [1]},
  {"id": 6, "use": true, "param": "min_weight_fraction_leaf", "type": "float", "default_value": 0.0, "name": "Минимальная взвешенная доля суммы весов.", "info": "Минимальная взвешенная доля суммы весов (всех входных выборок), которая должна находиться в листовом узле. Выборки имеют одинаковый вес, если параметр sample_weight не указан.", "diap": [0]},
  {"id": 7, "use": true, "param": "max_features", "type": "string", "default_value": "sqrt", "name": "Количество особенностей, которые следует учитывать при поиске лучшего разделения.", "info": "Если «sqrt», то max_features=sqrt(n_features). Если «log2», то max_features=log2(n_features). Если Нет, то max_features=n_features.\n\nПримечание: поиск разделения не прекращается до тех пор, пока не будет найден хотя бы один действительный раздел образцов узлов, даже если для этого требуется эффективно проверить не только max_featuresфункции.", "diap": [null, "sqrt", "log2"]},
  {"id": 8, "use": true, "param": "max_leaf_nodes", "type": "int", "default_value": null, "name": "Оптимизатор роста дерева", "info": "Вырастите дерево max_leaf_nodesсамым лучшим способом. Лучшие узлы определяются как относительное уменьшение примесей. Если нет, то неограниченное количество конечных узлов.", "diap": [0]},
  {"id": 9, "use": true, "param": "class_weight", "type": "string", "default_value": null, "name": "Веса классов", "info": "Веса, связанные с классами в форме . Если None, все классы должны иметь вес один. «Сбалансированный» режим использует значения y для автоматической корректировки весов, обратно пропорциональных частотам классов во входных данных, какn_samples / (n_classes * np.bincount(y))", "diap": [null, "balanced", "balanced_subsample"]}
]