[
  {"id": 1, "use": true, "param": "criterion", "type": "string", "default_value": {"label": "gini", "value":  "gini"}, "name": "Качество разделения", "info": "Функция для измерения качества разделения.", "diap": ["gini", "entropy", "log_loss"]},
  {"id": 2, "use": true, "param": "splitter", "type": "string", "default_value": {"label": "best", "value":  "best"}, "name": "Стратегия разделения", "info": "Стратегия, используемая для выбора разделения на каждом узле. Поддерживаемые стратегии: «best-лучшие» для выбора лучшего разделения и «random-случайные» для выбора лучшего случайного разделения.", "diap": ["best", "random"]},
  {"id": 3, "use": true, "param": "max_depth", "type": "int", "default_value": null, "name": "Максимальная глубина дерева", "info": "Если None, то узлы расширяются до тех пор, пока все листья не станут чистыми или пока все листья не будут содержать менее min_samples_split выборок.", "diap": [0]},
  {"id": 4, "use": true, "param": "min_samples_split", "type": "float", "default_value": 0.2, "name": "Минимальное разбиение выбоки", "info": "Если число с плавающей запятой, то min_samples_splitэто дробь и минимальное количество выборок для каждого разделения.ceil(min_samples_split * n_samples)", "diap": [0, 1]},
  {"id": 5, "use": true, "param": "min_samples_leaf", "type": "int", "default_value": 1, "name": "Минимальное количество выборок, которое должно находиться в листовом узле.", "info": "Точка разделения на любой глубине будет учитываться только в том случае, если она оставляет хотя бы min_samples_leafобучающие выборки в каждой из левой и правой ветвей. Это может привести к сглаживанию модели, особенно в регрессионном режиме. Если int, то считать min_samples_leafминимальным числом. Если с плавающей запятой, то min_samples_leafэто дробь и минимальное количество выборок для каждого узла.ceil(min_samples_leaf * n_samples)", "diap": [1]},
  {"id": 6, "use": true, "param": "max_features", "type": "string", "default_value": null, "name": "Количество особенностей, которые следует учитывать при поиске лучшего разделения.", "info": "Если «sqrt», то max_features=sqrt(n_features). Если «log2», то max_features=log2(n_features). Если Нет, то max_features=n_features.\n\nПримечание: поиск разделения не прекращается до тех пор, пока не будет найден хотя бы один действительный раздел образцов узлов, даже если для этого требуется эффективно проверить не только max_featuresфункции.", "diap": [null, "auto", "sqrt", "log2"]},
  {"id": 7, "use": true, "param": "random_state", "type": "int", "default_value": null, "name": "Управляет случайностью оценки.", "info": "Объекты всегда случайным образом переставляются при каждом разбиении, даже если splitterустановлено значение \"best\". Когда , алгоритм будет выбирать случайным образом для каждого разделения, прежде чем найти среди них лучшее разделение. Но наилучшее найденное разделение может различаться в разных прогонах, даже если . Это тот случай, когда улучшение критерия одинаково для нескольких разбиений и одно разбиение должно быть выбрано случайным образом. Чтобы получить детерминированное поведение во время подгонки, необходимо зафиксировать целое число. .max_features < n_featuresmax_featuresmax_features=n_featuresrandom_state", "diap": [0]},
  {"id": 8, "use": true, "param": "max_leaf_nodes", "type": "int", "default_value": null, "name": "Оптимизатор роста дерева", "info": "Вырастите дерево max_leaf_nodesсамым лучшим способом. Лучшие узлы определяются как относительное уменьшение примесей. Если нет, то неограниченное количество конечных узлов.", "diap": [0]},
  {"id": 9, "use": true, "param": "min_impurity_decrease", "type": "float", "default_value": 0.0, "name": "Делитель узла", "info": "Узел будет разделен, если это разделение приведет к уменьшению примеси, превышающему или равное этому значению.", "diap": [0]},
  {"id": 10, "use": true, "param": "class_weight", "type": "string", "default_value": null, "name": "Веса классов", "info": "Веса, связанные с классами в форме . Если None, все классы должны иметь вес один. «Сбалансированный» режим использует значения y для автоматической корректировки весов, обратно пропорциональных частотам классов во входных данных, какn_samples / (n_classes * np.bincount(y))", "diap": [null, "balanced"]},
  {"id": 11, "use": true, "param": "ccp_alpha", "type": "float", "default_value": 0.0, "name": "Параметр сложности", "info": "Параметр сложности, используемый для сокращения минимальной стоимости и сложности. ccp_alphaБудет выбрано поддерево с наибольшей стоимостью сложности, меньшей . По умолчанию обрезка не выполняется.", "diap": [0]},
  {"id": 12, "use": true, "param": "min_weight_fraction_leaf", "type": "float", "default_value": 0.0, "name": "Минимальная взвешенная доля суммы весов.", "info": "Минимальная взвешенная доля суммы весов (всех входных выборок), которая должна находиться в листовом узле. Выборки имеют одинаковый вес, если параметр sample_weight не указан.", "diap": [0]}
]