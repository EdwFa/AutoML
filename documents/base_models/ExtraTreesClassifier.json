[
  {"id": 1, "use": true, "param": "n_estimators", "type": "int", "default_value": 100, "name": "количество оценщиков", "info": "Количество деревьев в лесу.", "diap": [1]},
  {"id": 2, "use": true, "param": "criterion", "type": "string", "default_value": {"label": "gini", "value":  "gini"}, "name": "критерий", "info": "Функция для измерения качества разделения. Поддерживаемые критерии: «джини» для примеси Джини, а также «log_loss» и «энтропия» для прироста информации Шеннона, см. Математическая формулировка. Примечание. Этот параметр зависит от дерева.", "diap": ["gini", "entropy", "log_loss"]},
  {"id": 3, "use": true, "param": "max_depth", "type": "int", "default_value": null, "name": "Максимальная глубина дерева", "info": "Если None, то узлы расширяются до тех пор, пока все листья не станут чистыми или пока все листья не будут содержать менее min_samples_split выборок.", "diap": [0]},
  {"id": 4, "use": true, "param": "min_samples_split", "type": "float", "default_value": 0.1, "name": "Минимальное разбиение выбоки", "info": "Если число с плавающей запятой, то min_samples_splitэто дробь и минимальное количество выборок для каждого разделения.ceil(min_samples_split * n_samples)", "diap": [0, 1]},
  {"id": 5, "use": true, "param": "min_samples_leaf", "type": "int", "default_value": 0.1, "name": "Минимальное количество выборок, которое должно находиться в листовом узле.", "info": "Точка разделения на любой глубине будет учитываться только в том случае, если она оставляет хотя бы min_samples_leafобучающие выборки в каждой из левой и правой ветвей. Это может привести к сглаживанию модели, особенно в регрессионном режиме. Если int, то считать min_samples_leafминимальным числом. Если с плавающей запятой, то min_samples_leafэто дробь и минимальное количество выборок для каждого узла.ceil(min_samples_leaf * n_samples)", "diap": [0, 1]},
  {"id": 6, "use": true, "param": "min_weight_fraction_leaf", "type": "float", "default_value": 0.0, "name": "Минимальная взвешенная доля суммы весов.", "info": "Минимальная взвешенная доля суммы весов (всех входных выборок), которая должна находиться в листовом узле. Выборки имеют одинаковый вес, если параметр sample_weight не указан.", "diap": [0, 0.5]},
  {"id": 7, "use": true, "param": "max_features", "type": "string", "default_value": "sqrt", "name": "Количество особенностей, которые следует учитывать при поиске лучшего разделения.", "info": "Если «sqrt», то max_features=sqrt(n_features). Если «log2», то max_features=log2(n_features). Если Нет, то max_features=n_features.Примечание: поиск разделения не прекращается до тех пор, пока не будет найден хотя бы один действительный раздел образцов узлов, даже если для этого требуется эффективно проверить не только max_featuresфункции.", "diap": [null, "sqrt", "log2"]},
  {"id": 9, "use": true, "param": "max_leaf_nodes", "type": "int", "default_value": null, "name": "Оптимизатор роста дерева", "info": "Выращивайте деревья с помощью max_leaf_nodes наилучшим образом. Лучшие узлы определяются как относительное уменьшение примесей. Значения должны находиться в диапазоне [2, инф). Если Нет, то неограниченное количество конечных узлов.", "diap": [0]},
  {"id": 10, "use": true, "param": "bootstrap", "type": "bool", "default_value": false, "name": "самозагрузка", "info": "Используются ли бутстрап-образцы при построении деревьев. Если значение равно False, для построения каждого дерева используется весь набор данных.", "diap": null},
  {"id": 11, "use": true, "param": "oob_score", "type": "bool", "default_value": false, "name": "ООБ счетчик", "info": "Следует ли использовать готовые образцы для оценки оценки обобщения. По умолчанию используется точность_score. Предоставьте вызываемый объект с метрикой подписи (y_true, y_pred), чтобы использовать пользовательскую метрику. Доступно только в том случае, если bootstrap=True.", "diap": null},
  {"id": 12, "use": true, "param": "class_weight", "type": "string", "default_value": null, "name": "Веса классов", "info": "Веса, связанные с классами в форме . Если None, все классы должны иметь вес один. «Сбалансированный» режим использует значения y для автоматической корректировки весов, обратно пропорциональных частотам классов во входных данных, какn_samples / (n_classes * np.bincount(y))", "diap": [null, "balanced", "balanced_subsample"]},
  {"id": 13, "use": true, "param": "ccp_alpha", "type": "float", "default_value": 0.0, "name": "Параметр сложности", "info": "Параметр сложности, используемый для сокращения минимальной стоимости и сложности. ccp_alphaБудет выбрано поддерево с наибольшей стоимостью сложности, меньшей . По умолчанию обрезка не выполняется.", "diap": [0]},
  {"id": 14, "use": true, "param": "verbose", "type": "int", "default_value": 0, "name": "Подробность", "info": "Для решателей liblinear и lbfgs установите для verbose любое положительное число.", "diap": [0]},
  {"id": 15, "use": true, "param": "random_state", "type": "int", "default_value": null, "name": "Управляет случайностью оценки.", "info": "Объекты всегда случайным образом переставляются при каждом разбиении, даже если splitterустановлено значение \"best\". Когда , алгоритм будет выбирать случайным образом для каждого разделения, прежде чем найти среди них лучшее разделение. Но наилучшее найденное разделение может различаться в разных прогонах, даже если . Это тот случай, когда улучшение критерия одинаково для нескольких разбиений и одно разбиение должно быть выбрано случайным образом. Чтобы получить детерминированное поведение во время подгонки, необходимо зафиксировать целое число. .max_features < n_featuresmax_featuresmax_features=n_featuresrandom_state", "diap": [0]},
  {"id": 16, "use": true, "param": "warm_start", "type": "bool", "default_value": false, "name": "Тепловое начало", "info": "Если установлено значение True, повторно используйте решение предыдущего вызова в качестве инициализации, в противном случае просто сотрите предыдущее решение. Бесполезно для линейного решателя", "diap": null},
  {"id": 17, "use": true, "param": "max_samples", "type": "float", "default_value": null, "name": "максимальное количество образцов", "info": "Если начальная загрузка имеет значение True, количество выборок, которые нужно извлечь из X для обучения каждого базового оценщика. Если «Нет» (по умолчанию), то рисуются образцы X.shape[0]. Если int, то рисуйте образцы max_samples. Если имеет плавающее значение, то рисуются образцы max_samples * X.shape[0]. Таким образом, max_samples должно находиться в интервале (0,0, 1,0].", "diap": [0, 1]},
  {"id": 18, "use": true, "param": "is_permutate", "type": "bool", "default_value": false, "name": "Считать значимость факторов", "info": "Следует ли высчитывать значимость факторов, учтите что время их выполнения много больше обучения модели и предпочтительно использовать это уже на обученных моделях для улучшения результатов", "diap": null}
]