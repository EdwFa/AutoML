[
  {"id": 1, "use": true, "param": "loss", "type": "string", "default_value": {"label": "log_loss", "value":  "log_loss"}, "name": "ошибка", "info": "Функция потерь, подлежащая оптимизации. «log_loss» относится к биномиальному и полиномиальному отклонению, такому же, как и в логистической регрессии. Это хороший выбор для классификации с вероятностными результатами. Для «экспоненциальных» потерь повышение градиента восстанавливает алгоритм AdaBoost.", "diap": ["log_loss"]},
  {"id": 2, "use": true, "param": "learning_rate", "type": "float", "default_value": 0.01, "name": "скорость обучения", "info": "Скорость обучения уменьшает вклад каждого дерева на значение Learning_rate. Существует компромисс между Learning_rate и n_estimators. Значения должны находиться в диапазоне [0,0, inf).", "diap": [0]},
  {"id": 3, "use": true, "param": "max_iter", "type": "int", "default_value": 100, "name": "Максимальное количество итераций.", "info": "Максимальное количество итераций процесса бустинга, т.е. максимальное количество деревьев для бинарной классификации. Для мультиклассовой классификации на итерацию строится n_classes деревьев.", "diap": [1]},
  {"id": 4, "use": true, "param": "max_depth", "type": "int", "default_value": null, "name": "Максимальная глубина дерева", "info": "Если None, то узлы расширяются до тех пор, пока все листья не станут чистыми или пока все листья не будут содержать менее min_samples_split выборок.", "diap": [1]},
  {"id": 5, "use": true, "param": "min_samples_leaf", "type": "int", "default_value": 20, "name": "Минимальное количество выборок, которое должно находиться в листовом узле.", "info": "Минимальное количество выборок, которое должно находиться в листовом узле. Точка разделения на любой глубине будет учитываться только в том случае, если она оставляет как минимум обучающие выборки min_samples_leaf в каждой из левой и правой ветвей. Это может привести к сглаживанию модели, особенно в регрессионном режиме.", "diap": [0]},
  {"id": 7, "use": true, "param": "max_leaf_nodes", "type": "int", "default_value": 31, "name": "Оптимизатор роста дерева", "info": "Выращивайте деревья с помощью max_leaf_nodes наилучшим образом. Лучшие узлы определяются как относительное уменьшение примесей. Значения должны находиться в диапазоне [2, инф). Если Нет, то неограниченное количество конечных узлов.", "diap": [2]},
  {"id": 8, "use": true, "param": "verbose", "type": "int", "default_value": 0, "name": "Подробность", "info": "Для решателей liblinear и lbfgs установите для verbose любое положительное число.", "diap": [0]},
  {"id": 9, "use": true, "param": "random_state", "type": "int", "default_value": null, "name": "Управляет случайностью оценки.", "info": "Объекты всегда случайным образом переставляются при каждом разбиении, даже если splitterустановлено значение \"best\". Когда , алгоритм будет выбирать случайным образом для каждого разделения, прежде чем найти среди них лучшее разделение. Но наилучшее найденное разделение может различаться в разных прогонах, даже если . Это тот случай, когда улучшение критерия одинаково для нескольких разбиений и одно разбиение должно быть выбрано случайным образом. Чтобы получить детерминированное поведение во время подгонки, необходимо зафиксировать целое число. .max_features < n_featuresmax_featuresmax_features=n_featuresrandom_state", "diap": [0]},
  {"id": 10, "use": true, "param": "warm_start", "type": "bool", "default_value": false, "name": "Тепловое начало", "info": "Если установлено значение True, повторно используйте решение предыдущего вызова в качестве инициализации, в противном случае просто сотрите предыдущее решение. Бесполезно для линейного решателя", "diap": null},
  {"id": 11, "use": true, "param": "n_iter_no_change", "type": "int", "default_value": null, "name": "Количество итераций без изменений", "info": "", "diap": [0]},
  {"id": 12, "use": true, "param": "tol", "type": "float", "default_value": 0.0001, "name": "Допуск по критериям остановки.", "info": "Допуск по критериям остановки.", "diap": [0]},
  {"id": 13, "use": true, "param": "validation_fraction", "type": "float", "default_value": 0.1, "name": "Валидационное разбиение", "info": "Доля обучающих данных, которые необходимо отложить в качестве набора проверки для ранней остановки. Значения должны находиться в диапазоне (0,0, 1,0). Используется только в том случае, если для параметра n_iter_no_change установлено целое число.", "diap": [0, 1]},
  {"id": 14, "use": true, "param": "l2_regularization", "type": "float", "default_value": 0, "name": "Параметр регуляризации L2.", "info": "", "diap": [0]},
  {"id": 15, "use": true, "param": "max_bins", "type": "int", "default_value": 255, "name": "Максимальное количество интервалов, используемых для непропущенных значений.", "info": "Максимальное количество интервалов, используемых для непропущенных значений. Перед обучением каждая функция входного массива X разбивается на целочисленные ячейки, что позволяет значительно ускорить этап обучения. Объекты с небольшим количеством уникальных значений могут использовать ячейки меньше max_bins. Помимо контейнеров max_bins, для отсутствующих значений всегда зарезервирован еще один контейнер. Должно быть не больше 255.", "diap": [0, 255]},
  {"id": 16, "use": true, "param": "interaction_cst", "type": "string", "default_value": null, "name": "ограничения взаимодействия", "info": "Укажите ограничения взаимодействия, наборы функций, которые могут взаимодействовать друг с другом в разделениях дочерних узлов.\nКаждый элемент определяет набор индексов функций, которым разрешено взаимодействовать друг с другом. Если объектов больше, чем указано в этих ограничениях, они обрабатываются так, как если бы они были указаны как дополнительный набор.\nСтроки «pairwise» и «no_interactions» обозначают разрешение только парного взаимодействия или отсутствие взаимодействия соответственно.", "diap": ["pairwise", "no_interactions"]},
  {"id": 17, "use": true, "param": "is_permutate", "type": "bool", "default_value": false, "name": "Считать значимость факторов", "info": "Следует ли высчитывать значимость факторов, учтите что время их выполнения много больше обучения модели и предпочтительно использовать это уже на обученных моделях для улучшения результатов", "diap": null}
]
