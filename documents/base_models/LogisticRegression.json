[
  {"id": 1, "use": true, "param": "penalty", "type": "string", "default_value": {"label": "l2", "value":  "l2"}, "name": "Функция штрафа", "info": "Укажите норму штрафа: Нет: штраф не добавляется; «l2»: добавьте штрафной срок L2, и это выбор по умолчанию; 'l1': добавить штрафной срок L1; «elasticnet»: добавлены штрафные санкции L1 и L2. Предупреждение. Некоторые штрафы могут не работать с некоторыми решателями.", "diap": [null, "l1", "l2", "elasticnet"]},
  {"id": 2, "use": true, "param": "dual", "type": "bool", "default_value": false, "name": "Использовать двойственность", "info": "Двойственная (ограниченная) или основная (регуляризованная, см. также это уравнение) формулировка. Двойная формулировка реализована только для штрафа l2 с помощью линейного решателя. Предпочитайте двойной = False, когда n_samples > n_features.", "diap": null},
  {"id": 3, "use": true, "param": "tol", "type": "float", "default_value": 0.0001, "name": "Критерий остановки.", "info": "Допуск по критериям остановки.", "diap": [0]},
  {"id": 4, "use": true, "param": "C", "type": "float", "default_value": 1, "name": "Инверсия силы регуляризации", "info": "Инверсия силы регуляризации; должно быть положительным плавающим значением. Как и в машинах опорных векторов, меньшие значения определяют более сильную регуляризацию.", "diap": [0]},
  {"id": 5, "use": true, "param": "fit_intercept", "type": "bool", "default_value": true, "name": "Смещение", "info": "Указывает, следует ли добавлять к функции принятия решения константу (т. е. смещение или перехват).", "diap": null},
  {"id": 6, "use": true, "param": "class_weight", "type": "string", "default_value": null, "name": "Веса классов", "info": "Веса, связанные с классами в форме . Если None, все классы должны иметь вес один. «Сбалансированный» режим использует значения y для автоматической корректировки весов, обратно пропорциональных частотам классов во входных данных, какn_samples / (n_classes * np.bincount(y))", "diap": [null, "balanced"]},
  {"id": 7, "use": true, "param": "random_state", "type": "int", "default_value": null, "name": "Управляет случайностью оценки.", "info": "Объекты всегда случайным образом переставляются при каждом разбиении, даже если splitterустановлено значение \"best\". Когда , алгоритм будет выбирать случайным образом для каждого разделения, прежде чем найти среди них лучшее разделение. Но наилучшее найденное разделение может различаться в разных прогонах, даже если . Это тот случай, когда улучшение критерия одинаково для нескольких разбиений и одно разбиение должно быть выбрано случайным образом. Чтобы получить детерминированное поведение во время подгонки, необходимо зафиксировать целое число. .max_features < n_featuresmax_featuresmax_features=n_featuresrandom_state", "diap": [0]},
  {"id": 8, "use": true, "param": "solver", "type": "string", "default_value": {"label": "lbfgs", "value": "lbfgs"}, "name": "Решатель", "info": "Алгоритм, используемый в задаче оптимизации. По умолчанию — «lbfgs». Чтобы выбрать решатель, вы можете рассмотреть следующие аспекты: Для небольших наборов данных хорошим выбором является «лилинейный», тогда как «провисание» и «сага» работают быстрее для больших; Для многоклассовых задач только «newton-cg», «sag», «saga» и «lbfgs» обрабатывают полиномиальные потери; «liblinear» ограничен схемами «один против остальных». «newton-cholesky» — хороший выбор для n_samples >> n_features, особенно с категориальными признаками с горячим кодированием и редкими категориями. Обратите внимание, что он ограничен бинарной классификацией и сокращением «один против остальных» для многоклассовой классификации. Имейте в виду, что использование памяти этим решателем имеет квадратичную зависимость от n_features, поскольку он явно вычисляет матрицу Гессе. Внимание! Выбор алгоритма зависит от выбранного штрафа. Поддерживаемые штрафы решателем: ‘lbfgs’ — [’l2’, нет] ‘liblinear' - ['l1', 'l2'] 'newton-cg' - ['l2', нет] 'newton-cholesky' - ['l2', нет] 'sag' - ['l2', Нет] 'saga' - [«elasticnet», «l1», «l2», нет]", "diap": ["lbfgs", "liblinear", "newton-cg", "newton-cholesky", "sag", "saga"]},
  {"id": 9, "use": true, "param": "max_iter", "type": "int", "default_value": 100, "name": "Максимальное кол-во иттераций обучения", "info": "Максимальное количество итераций, необходимое для сходимости решателей", "diap": [1]},
  {"id": 10, "use": true, "param": "multi_class", "type": "string", "default_value": {"label": "auto", "value": "auto"}, "name": "мультикласс", "info": "Если выбран вариант «ovr», то для каждой метки подходит бинарная задача. Для «мультиномиального» минимизированные потери — это полиномиальные потери, соответствующие всему распределению вероятностей, даже если данные являются двоичными. «Мультиномиальный» недоступен, если Solver = «liblinear». «auto» выбирает «ovr», если данные двоичные или если Solver = «liblinear», а в противном случае выбирает «мультиномиальный».", "diap": ["auto", "ovr", "multinomial"]},
  {"id": 11, "use": true, "param": "verbose", "type": "int", "default_value": 0, "name": "Подробность", "info": "Для решателей liblinear и lbfgs установите для verbose любое положительное число.", "diap": [0]},
  {"id": 12, "use": true, "param": "warm_start", "type": "bool", "default_value": false, "name": "Тепловое начало", "info": "Если установлено значение True, повторно используйте решение предыдущего вызова в качестве инициализации, в противном случае просто сотрите предыдущее решение. Бесполезно для линейного решателя", "diap": null},
  {"id": 13, "use": true, "param": "is_permutate", "type": "bool", "default_value": false, "name": "Считать значимость факторов", "info": "Следует ли высчитывать значимость факторов, учтите что время их выполнения много больше обучения модели и предпочтительно использовать это уже на обученных моделях для улучшения результатов", "diap": null}
]